package models

import (
	"fmt"

	"sync"

	"time"

	"math"

	"encoding/gob"

	"os"

	"github.com/SmartMeshFoundation/SmartRaiden/channel"
	"github.com/SmartMeshFoundation/SmartRaiden/log"
	"github.com/SmartMeshFoundation/SmartRaiden/transfer"
	"github.com/asdine/storm"
	gobcodec "github.com/asdine/storm/codec/gob"
	bolt "github.com/coreos/bbolt"
	"github.com/ethereum/go-ethereum/common"
)

//ModelDB is thread safe
type ModelDB struct {
	db                      *storm.DB
	lock                    sync.Mutex
	newTokenCallbacks       map[*NewTokenCb]bool
	newChannelCallbacks     map[*ChannelCb]bool
	channelDepositCallbacks map[*ChannelCb]bool
	channelStateCallbacks   map[*ChannelCb]bool
	mlock                   sync.Mutex
	Name                    string
	//SentTransferChan SentTransfer notify ,should never close
	SentTransferChan chan *SentTransfer
	//ReceivedTransferChan  ReceivedTransfer notify, should never close
	ReceivedTransferChan chan *ReceivedTransfer
}

/*
InternalEvent is event of raiden itself
*/
type InternalEvent struct {
	ID            int `storm:"id,increment"`
	StateChangeID int
	BlockNumber   int64 `storm:"index"`
	EventObject   transfer.Event
}

//StateChange to save to db
type StateChange struct {
	ID          int `storm:"id,increment"`
	StateChange transfer.StateChange
}

type snapshotToWrite struct {
	ID            int
	StateChangeID int
	State         interface{}
}

var bucketEvents = []byte("events")
var bucketEventsBlock = []byte("eventsBlock")
var bucketStateChange = []byte("statechange")
var bucketSnapshot = "snapshot"
var bucketMeta = "meta"

const dbVersion = 1

func newModelDB() (db *ModelDB) {
	return &ModelDB{
		newTokenCallbacks:       make(map[*NewTokenCb]bool),
		newChannelCallbacks:     make(map[*ChannelCb]bool),
		channelDepositCallbacks: make(map[*ChannelCb]bool),
		channelStateCallbacks:   make(map[*ChannelCb]bool),
		SentTransferChan:        make(chan *SentTransfer, 10),
		ReceivedTransferChan:    make(chan *ReceivedTransfer, 10),
	}

}

//OpenDb open or create a bolt db at dbPath
func OpenDb(dbPath string) (model *ModelDB, err error) {
	model = newModelDB()
	needCreateDb := !common.FileExist(dbPath)
	var ver int
	model.db, err = storm.Open(dbPath, storm.BoltOptions(os.ModePerm, &bolt.Options{Timeout: 1 * time.Second}), storm.Codec(gobcodec.Codec))
	if err != nil {
		err = fmt.Errorf("cannot create or open db:%s,makesure you have write permission err:%v", dbPath, err)
		log.Crit(err.Error())
		return
	}
	model.Name = dbPath
	if needCreateDb {
		err = model.db.Set(bucketMeta, "version", dbVersion)
		if err != nil {
			log.Crit(fmt.Sprintf("unable to create db "))
			return
		}
		//write a empty snapshot,
		model.db.Save(&snapshotToWrite{ID: 1})
		err = model.db.Set(bucketToken, keyToken, make(AddressMap))
		if err != nil {
			log.Crit(fmt.Sprintf("unable to create db "))
			return
		}
		model.initDb()
		model.MarkDbOpenedStatus()
	} else {
		err = model.db.Get(bucketMeta, "version", &ver)
		if err != nil {
			log.Crit(fmt.Sprintf("wrong db file format "))
			return
		}
		if ver != dbVersion {
			log.Crit("db version not match")
		}
		var closeFlag bool
		err = model.db.Get(bucketMeta, "close", &closeFlag)
		if err != nil {
			log.Crit(fmt.Sprintf("db meta data error"))
		}
		if closeFlag != true {
			log.Error("database not closed  last..., try to restore?")
		}
	}

	return
}

/*
MarkDbOpenedStatus First step   open the database
Second step detection for normal closure IsDbCrashedLastTime
Third step  recovers the data according to the second step
Fourth step mark the database for processing the data normally. MarkDbOpenedStatus
*/
func (model *ModelDB) MarkDbOpenedStatus() {
	model.db.Set(bucketMeta, "close", false)
}

//IsDbCrashedLastTime return true when quit but  db not closed
func (model *ModelDB) IsDbCrashedLastTime() bool {
	var closeFlag bool
	err := model.db.Get(bucketMeta, "close", &closeFlag)
	if err != nil {
		log.Crit(fmt.Sprintf("db meta data error"))
	}
	return closeFlag != true
}

//CloseDB close db
func (model *ModelDB) CloseDB() {
	model.lock.Lock()
	model.db.Set(bucketMeta, "close", true)
	model.db.Close()
	model.lock.Unlock()
}

//SaveRegistryAddress save registry address to db
func (model *ModelDB) SaveRegistryAddress(registryAddress common.Address) {
	model.db.Set(bucketMeta, "registry", registryAddress)
}

//GetRegistryAddress returns registry address in db
func (model *ModelDB) GetRegistryAddress() common.Address {
	var registry common.Address
	model.db.Get(bucketMeta, "registry", &registry)
	return registry
}

//LogStateChange Log a state change and return its identifier
func (model *ModelDB) LogStateChange(stateChange transfer.StateChange) (id int, err error) {
	sc := &StateChange{
		StateChange: stateChange,
	}
	err = model.db.Save(sc)
	id = sc.ID
	return
}

//LogEvents  Log the events that were generated by `state_change_id` into the write ahead Log
func (model *ModelDB) LogEvents(stateChangeID int, events []transfer.Event, currentBlockNumber int64) error {
	for _, e := range events {
		err := model.db.Save(&InternalEvent{
			StateChangeID: stateChangeID,
			BlockNumber:   currentBlockNumber,
			EventObject:   e,
		})
		if err != nil {
			return err
		}
	}
	return nil
}

/*
GetEventsInBlockRange Get the raiden events in the period (inclusive) ranging from
        `from_block` to `to_block`.
*/
func (model *ModelDB) GetEventsInBlockRange(fromBlock, toBlock int64) (events []*InternalEvent, err error) {
	if fromBlock < 0 {
		fromBlock = 0
	}
	if toBlock < 0 {
		toBlock = math.MaxInt64
	}
	err = model.db.Range("BlockNumber", fromBlock, toBlock, &events)
	if err == storm.ErrNotFound { //ingore not found error
		err = nil
	}
	return
}

//GetStateChangeByID get state change by id
func (model *ModelDB) GetStateChangeByID(id int) (st transfer.StateChange, err error) {
	var sc StateChange
	err = model.db.One("ID", id, &sc)
	if err != nil {
		return
	}
	st = sc.StateChange
	return
}

//Snapshot save snapshot to db
func (model *ModelDB) Snapshot(stateChangeID int, state interface{}) (id int, err error) {
	s := &snapshotToWrite{
		ID:            1,
		StateChangeID: stateChangeID,
		State:         state,
	}
	err = model.db.Update(s)
	return 1, err
}

//LoadSnapshot get last snapshort
func (model *ModelDB) LoadSnapshot() (state interface{}, err error) {
	var sw snapshotToWrite
	err = model.db.One("ID", 1, &sw)
	if err == nil {
		state = sw.State
	}
	if state == nil {
		err = storm.ErrNotFound
	}
	return
}
func init() {
	gob.Register(&InternalEvent{})
	gob.Register(&snapshotToWrite{})
	gob.Register(common.Address{})
	gob.Register(&ModelDB{}) //cannot save and restore by gob,only avoid noise by gob
}

func (model *ModelDB) initDb() {
	model.db.Init(&InternalEvent{})
	model.db.Init(&snapshotToWrite{})
	model.db.Init(&StateChange{})
	model.db.Init(&channel.Serialization{})
	model.db.Init(&SentTransfer{})
	model.db.Init(&ReceivedTransfer{})
	model.db.Set(bucketBlockNumber, keyBlockNumber, 0)
}
